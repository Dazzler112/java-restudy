
지난 학습에 두 가지 기초적 데이터 구조를 봤었다

하나는 Array(배열)이다, 배열은 모든 요소들을 순서대로 저장하고 언제나 너가 요소를 하나 제거하면 그 요소를 제거한 후
그 다음 요소를 모두 왼쪽으로 밀어야 한다.
하지만 배열의 특정한 위치에 있는 요소를 갖고 오는 건 아주 쉽다.

                                   Array
| 123 | 140 | 20 | 50 | 70 | 80 | 100 | 180 | 25 | 1 | 8 | 10 | 12 | 23 | 10 |
   0     1    2    3    4    5     6     7    8    9   10  11   12   13   14

직접적으로 인덱스 5에 있는 요소를 취히려고 하면 바로 80이란 값을 얻을 수 있다.

또 다른 데이터 구조는 LinkedList였다 LinkedList에서는, 

                      LinkedList

    TOP  ㅁ
       ↙
  | 45 || → | 25 || → | 4 || → | 13 || → | 6 || → | 5|\|  
각자 요소들은 다음 요소들과 연결되어 있고 Doubly LinkedList에서는 25는, 45와 연결된 것처럼 4와도 연결돼 있다.
이것이 Doubly LinkedList이다 LinkedList에선, 삽입과 제거가 더 쉬운데 왜냐하면 25를 제거해야 한다면 45에서 4로 옮겨 25를 제거한다
삽입 한다면, 예를 들어, 이 25, 4 사이에 21을 넣고 싶으면, 21을 25의 연결을 21로 이어주고, 21을 4와 이어주면 된다.

하지만, LinkedList를 가지고는 특정 위치에 있는 요소를 갖고 오거나 무언가를 찾는 것은 소모적인 작업이다, 
왜냐하면 연결점들을 다 건너 다니며 무엇이 리스트에 존재하는지 찾아야 하기 때문이다.



이번 학습에 집중해서 볼 데이터 구조는 HashTable이다


                                  • Hashing

                                    
                                    |  /  |
                                    |  45 |
                                    -------                                                                    
                                       ↑                                                                      
                                    |  /  |                 |  /  |                               
                                    |  58 |                 |  10 |                                                          
                                    -------                 -------                                                 
                                       ↑                       ↑
|  /  |     |  /  |                 |  /  |     |  /  |     |  /  |     |  /  |                                                         
|  13 |     |  15 |                 |  6  |     |  34 |     |  23 |     |  12 |                                                                                                                                      
-------     -------                 -------     -------     -------     -------                                                                                            
   ↑           ↑                       ↑           ↑           ↑           ↑                                       
|     |  \  |     |  \  |  \  |  \  |     |  \  |     |  \  |     |  \  |     |       
   0     1     2     3     4     5     6     7     8     9    10    11     12

이것은 요소들을 저장함에 있어 전혀 다른 접근을 한다
이것은 배열과 비슷한 고정된 위치들과 LinkedList의 장점들을 합치려 한다.
예를 들면, 여기 13가지의 다른 위치가 있다고 하자, 이 13개의 것들을 bucket이라 부르고, 각자 bucket에 요소를 저장할 수 있는 것이다.
이 bucket에 어떻게 요소를 저장할까?

해싱 함수라는 것이 있다.
15를 어디에 저장해야 할지 결정한다면 어느 bucket에 15를 저장해야 할지 정하는 것이다.

해싱 함수를 사용하면 된다
15를 계산하는 건데 여기서 해싱함수는 나머지 13 연산을 사용한다
즉,우리는 13으로 나누고 나머지를 구해서 그 bucket에 요소를 넣는 것이다. 
예를들면, 15나누기 13의 나머지는 2이다 그래서 이게 두번째 bucket에 있는것이다.

내가 34를 넣는다면 인덱스 8의 bucket에 들어있는것을 볼 수 있다.
왜냐면 34나누기 13의 나머지는 8이기 때문이다
34는, 13 곱하기 2 그러면 26, 34-26은 8이다
그래서 8번째 인덱스에 있는 것이다.

13나누기 13은 나머지가 0이니까 13은 0번째 인덱스에 있는것을 볼수 있다.

즉, 우리가 하는 것은 해싱 함수란 것을 이용하는 것이다, 
해싱함수는 어느bucket에 요소가 들어갈지 정해주는데 쓰인다, 이제 예를 들어 2를 삽입한다면 어떤일이 벌어질까?
2 나머지 13을 하겠지? 그럼 bucket 숫자는 2가 나온다 그래서, 2번자리에 저장하고 싶겠지 하지만 이미 15가 있다
이럴때는, 이 리스트에 2를 붙이게 된다 15에 더해서, 여기에 2도 가질 것이란 말이다
  예)  |  /  |
       |  2  |
          ↑
       |  /  |
       |  15 |
       -------
          ↑
       |     |
          2

34를 지우고 싶다 하자 여기서 할 일은, 34 나머지 13 8을 얻겠지?
그럼 여기로 와서 34가 있는지 보고, 34가 있으면 이요소는 지워진다

예를 들어, 이 특정한 HashTable에 4라는 요소가 존재하는지 알아보고 싶다고 하자
4나머지 13을 하겠지? 4나머지 13은 4
그래서 인덱스 4번 위치를 확인한다, 4번에는 아무것도 없다, 4는 이 리스트에 없음 

• HashTable의 장점
HashTable의 장점은 요소들을 쉽게 삽입할수 있고 검색과 제거 또한 훨씬 쉽게 할 수 있다는 점이다
HashTable은 매우 빠른 검색능력을 제공한다 요소의 삽입은 때때로는 LinkedList보다 느릴 수 있지만 
배열에 비해서는 훨씬 바르다

HashTable의 효율성은 언제나 너의 해싱 함수의 효율성에 기반한다 
자바에선, 우리는 해싱 함수를, 해시코드란 것을 이용해 구현한다

• hashcode
객체 클래스를 보면, hashcode()라는 메서드가 있다, 이 hashcode는 어느 bucket에 객체가 저장되는지를 경정하는데 쓰인다,
우리가 여기에서 쓴 해시 함수 나머지 13은 그저 예시일 뿐이다
여러 종류의 시나리오에 사용될 수 있는 다양한 해싱 함수가 있다 이 해싱 함수들은 우리는 hashcode()를 이용해 자바에서 구현할 수 있다.

/*
요점)
제일 중요한 것 중 하나는, 너는 해싱이나 HashTable의 전문가가 아니어도 된다는 점이다
이 설명은 너가 전체적으로 해싱을 이해하도록 하려는 것이다, 그래서 나중에 
HashTable에 기반한 컬렉션을 소개할 떄 너는 이게 백그라운드에서 어떻게 작동하는지 이해할 수 있다
*/






/*
정리)
요약하자면,HashTable의 중요한 부분은 해싱 함수이다
우리는 해싱 함수를 이용해 요소를 어느 bucket에 저장할지 결정하고, 
이미 그 bucket에 요소가 붙어있는데 새 요소를 삽입하려 할 때는
요소들의 리스트에 추가되겠지 HashTable은 검색을 매우 쉽게 해주는데, 
그 이유는 너가 직접 그 bucket에 가 요소들을 찾기 때문이다 
즉,너는 전체요소들의 리스트를 검색하는 것이 아니라
이 특정한 bucket안의 특정 요소들의 구성만 검색하기 때문이다
비슷한 논리가 삽입과 제거에서도 적용된다
*/
