
MultiThreading은 프로그래밍에 대한 개념중 가장 중요한 것 중 하나이다
이 학습에선 하나의 프로그램을 작성하고 왜 스레드가 꼭 필요한 것인지 알아보도록 하겠다



-----------------------------------------------------------------------------------



ThreadBasicsRunner 클래스 파일




package multiThreading;

public class ThreadBasicsRunner {
	
	public static void main(String[] args) {
		//지금 수행해야 하는 작업이 세 개라고 해보자
		//Task라 지정된 것들에 간단한 코드를 적용해 보겠다 
		
		//존재하는 Task들이 비슷한 작업을 하고 있다고 해보자
		
		//Task1
		for(int i = 101; i <= 199; i++ ) {
			System.out.print(i + " ");
		}
		System.out.print("\n Task1 Done");
		
		//Task2
		for(int i = 201; i <= 299; i++ ) {
			System.out.print(i + " ");
		}
		System.out.print("\nTask2 Done");
		//Task3
		for(int i = 301; i <= 399; i++ ) {
			System.out.print(i + " ");
		}
		System.out.print("\nTask3 Done");
		
		System.out.print("\nMain Done");
		//그럼 이 전체 코드를 실행하면 무슨 일이 일어날까?
		//한 task에 이어서 다른 task가 이어서 계속 실행되는 일이 생기는 것이다
		
		/*
		이게 전형적으로 프로그래밍을 하는 방법이다 
		정리하면 Task1에 해당하는 모든 작업이 끝나면 Task2, 그리고 이어서 Task3의 작업들이 실행되는 구조이다
		이게 기본적인 프로그래밍 방벙이었다 어떤 코드를 적든 실행됐었다 Task1줄 실행이 끝나면 다음줄로 넘어간다
		Task1 for문이 가장먼저 코드가 실행되고,이어서 다음 줄, 다음 줄,그 다음 줄의 코드가 실행된다
		여기엔 세 가지의 task가 존재한다 보편적으론 다수의 시나리오에선 Task1과 Task2,그리고3이 각각 서로에 대해 독립적으로 작용하지만
		
		몇몇 task는 외부의 실행에 의해 의존적으로 실행되기도 한다
		
		for(int i = 101; i <= 199; i++ ) {
			System.out.print(i + " ");
		}
		System.out.print("\n Task1 Done");
		여기선 아마 I/O나 이와 비슷한 것들에 달려있겠다
		
		그러므로 이 task의 실행 단계에서 사용자의 CPU는 충분히 활용되지 못할 것이다
		그런데도 CPU는 실행할 task가 단 한 가지만 존재한다
		그럼 어떤 일을 하는 것일까? 계속 기다리거나 대기할 것이다
		즉, Task2를 아무리 Task1과 유사한 실행과정을 거친다고 해도, CPU는 이 유사성을 인지하지 못한다
		그럼 어떤 일이 벌어질까? 계속 기다리거나 대기하는 상황이 이어질 것이다
		*/
	}
}

-----------------------------------------------------------------------------------





/*
정리)		
'Threads', 즉 스레드는 이렇게 유사성을 가진 모든 수행문을 동시에 실행하도록 해준다
이 thread를 실행하는 코드를 하나 작성하고, 또 다른 thread로 이 코드를 실행하고, 
또 다른 thread로 이 코드들을 실행한다
그러므로 유사한 구조를 가진 이 세 가지 task가 모두 실행되는 것이다, 
이로써 CPU의 효율성이 향상되는데, 이유는
외부 서비스나 데이터 자장소로부터 데이터 입력을 기다리면 지속해서 다른 task에 대한 정보를 얻을수 있기 때문이다 
*/
