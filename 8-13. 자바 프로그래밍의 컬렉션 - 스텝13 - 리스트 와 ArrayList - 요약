
이 단계에서는 우리가 리스트 인터페이스와 그의 몇 가지 구현에 대해 배운것을 복습해 보자

• List 설명
리스트는 컬렉션 인터페이스를 연장한다, 즉, 이것은 컬렉션 인터페이스에 있는 모든 것을 구현하고
거기에 더해서, 객체의 위치에 상관하는 메서드를 제공한다
그래서, 리스트의 끝이나 중간, 어디든 요소를 삽입할 수 있다.

• List 설명
우리는 리스트 인터페이스를 보았고 여러 메서드도 보았다
indexOf 도 보았고, 혹시 너가 lastIndexOf를 찾으려면, 리스트에는 중복이 있을 수 있는 만큼 
같은 요소가 세 개나 네 개 존재할 수도 있기 때문에 
lastIndexof()는 이 특정 요소의 마지막 위치를 찾는 데도 쓰일 수 있다

• Iterator 설명
우리는 리스트 인터페이스에 있는 다양한 메서드를 봤다 
그리고 우리는 반복자(Iterator)와 리스트를 어떻게 리스트로 돌릴지도 봤다

• List 구현 메서드 3가지
우리는 리스트 인터페이스의 세가지 다른 구현도 보았다
-하나는 ArrayList이다, 배열을 기초적 데이터 구조로 사용하는 것이다
 이것은 LinkedList에 비해 삽입과 제거가 더 느리다는 의미이다
 하지만 특정 위치의 특정 요소에 접근하고 싶다면, 매우 빨리 수행할 수 있다
-LinkeList는 기반되는 데이터 구조는 doubly linkedlist인 linkedlist이다,
 즉, 앞뒤의 요소와 연결이 있는 것이다 LinkedList의 특징은 반복하는 것과 특정 인덱스의 요소를 찾는 것은 
 ArrayList에 비해 훨씬 느리다는 것이다
 하지만, 요소의 삽입과 제거는 훨씬 빠르다 
-Vector라는, '스레드-안전' 한 리스트의 구현도 살펴 보았다, Vector는 동기화된 메서드를 이용해 스레드 안전을 구현한다
 하지만, 다중 스레드 시나리오에선 Vector는 성능 하락을 부를 수 있다, 
 왜냐면 Vector의 모든 메서드들은 동기화(Synchronized)되어 있기때문이다



/*
다음)
우리는 Vector의 스레드 안전에 대한 접근법인 동시적 컬렉션에 대해서도 알아보도록 하겠다
스레드에 대해 이야기하고 다음 단계에선, Set이라는 또다른 컬렉션 인터페이스에 대해 알아보자
*/
