8진수
int eight = 010;
eight ==> 8

16진수
int sixteen = 0x10;
sixteen ==> 16

octal(8진수) - 0 to 7
decimal(10진수) - 통상적으로 사용되는 체계 => 0 to 9
hexadecimal(16진수) - 0 to 9 , A=10 ,B=11 ,C=12 ,D=13 ,E=14 and F=15
이것을 활용하여 16진수를 만들어 보자

int fifteen = 0xF;
fifteen ==> 15
(근대 이렇게하지 말아라 코드 읽는사람만 햇갈린다. 꼭 필요한 경우가 아니면 코드를 복잡하게 만들 필요 X)

int eight = 099;
error
08도 안된다 8진수는 0~ 7이기 때문

int big = 0xBBAACC;
big ==> 12298956

short s = i;
error 
에러다 다시 복습하지만 자바는 사용변수의 크기를 고려한다!
int의 크기는 4바이트이고 short의 크기는 2바이트이기 때문에 4바이트값을 2바이트에 넣을수 없다
하려면 explicit 형변환을 해야한다
short s = (short) i; 
이렇게 하면 3456을 넣을수 있다
s ==> 3456

int i1 = s
i1 ==> 3456
이것은 implicit 형변환이다
int는 4바이트 short는 2바이트
s값이 상대적으로 더 작기때문에 당연히 가능

간단하게 컵에비유하면
작은컵은 당연히 큰컵이 들아갈수 없듯이
explicit 형변환하면 들어간다

반대로 작은컵을 큰컵안에 넣는것은 컴파일러가 자동으로 진행하는데
이걸 implicit형변환이라한다

증감연산자는 사후증감과 사전증감 두 종류로 나뉜다

사후증가
int i = 10;
i ==> 10

int j = i++;
j ==> 10

i i의 값을 구하면 11로 나온다
i의 값이 j의 값에 의해 증가했고, 증가 전 값을 j가 갖게 됐는대
사후 증감연산자 에서는 우선연산(i++)부터 실행된다
j가 i증가 발생전 값인 10을 받고 이후에 i가 11값을 받는다.

사전증가
int i = 10;
i ==> 10

int j = ++i;
j==> 11

i
i==>11

j와 i 둘 다 11의 값을 받는데
사전 증가에서 값이 배정되기 전에 먼저 시작하기 때문에
++i 부터 발생하여 i의 값은 10에서 11이되고 
11이 j에 배정된다.

사후감소 사전감소 역시 같다

쉽게 생각하면 
사후감산는 굉장히 느린놈이라 
i++ 시에 증감하지 않고 호출해야 증감된다
ex) int i = 1;
int j = i++;
==> 1
i or System.out.println(i)
==> 2
호출시 증감발동

사전감산은 굉장히 빠른놈이다 라고 생각하면 된다
++i 할시 바로 증감된다

int i = 1;
int j = ++i;
==> 2
i
==> 2
이렇게 증감 동시에 바로 증감되어버린다
사전은 굉장히 빠른놈 사후는 굉장히 느린놈 으로 알고 사용하면 쉽게 이해 할 수 있다.
